<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F07%2F15%2Fmysql%2F</url>
    <content type="text"><![CDATA[title: mysqldate: 2020-07-15 15:24:36tags: mysql 安装 mysql 1yum install mysql-server 查看版本 1mysql -V 运行 mysql 1service mysqld start 查看是否启动 1service mysqld status 获取初始密码 1grep &quot;password&quot; /var/log/mysqld.log 登陆 mysql 1mysql -uroot -p&apos;********&apos; 设置密码（“需要带数字，大写字母，小写字母，特殊符号”）如我设置密码为 Qc123456! 1SET PASSWORD = PASSWORD(&apos;你的新密码&apos;); 设置密码永不过期 1ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER; 刷新系统权限相关表 1flush privileges; 设置数据库用户在所有 ip 下以及在本地可访问,以下用 root 用户做演示 123grant all privileges on *.* to root@&quot;%&quot; identified by &quot;你的密码&quot;;grant all privileges on *.* to root@&quot;localhost&quot; identified by &quot;你的密码&quot;;flush privileges;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[downLoad]]></title>
    <url>%2F2020%2F06%2F26%2FdownLoad%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class DownLoad &#123; constructor(type) &#123; this.arr = &#123;&#125; this.type = type this.arr[type] = 0 &#125; int() &#123; this.arr[this.type] += 1 this.total() &#125; total() &#123; let num = Object.entries(this.arr).reduce((all, [key, value]) =&gt; &#123; all += value return all &#125;, 0); console.log(&apos;总数量：&apos;, num) return num &#125;&#125;class DownLoadSmall &#123; constructor(res = &#123; isDown: false, url: &apos;./1.png&apos; &#125;) &#123; this.arr = res &#125; start(DownLoad) &#123; if (this.arr.isDown) return this.arr return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; this.arr.isDown = true DownLoad.int() resolve(this.arr) &#125;, 500) &#125;) &#125;&#125;class Image &#123; constructor(images) &#123; this.images = images &#125; startDown(DownLoad) &#123; return new Promise(async resolve =&gt; &#123; for (let i = 0; i &lt; this.images.length; i++) &#123; let data = new DownLoadSmall(this.images[i]) this.images[i] = await data.start(DownLoad, this.images[i]) &#125; console.log(this.images) resolve() &#125;) &#125;&#125;let images = [ &#123; isDown: false, url: &apos;./1.png&apos; &#125;, &#123; isDown: false, url: &apos;./2.png&apos; &#125;, &#123; isDown: false, url: &apos;./3.png&apos; &#125;, &#123; isDown: false, url: &apos;./4.png&apos; &#125;, &#123; isDown: false, url: &apos;./5.png&apos; &#125;, &#123; isDown: false, url: &apos;./6.png&apos; &#125;, &#123; isDown: false, url: &apos;./7.png&apos; &#125;,]async function startDownImage() &#123; let imgClass = new DownLoad(&apos;image&apos;) let img = new Image(images) await img.startDown(imgClass) await img.startDown(imgClass)&#125;startDownImage()]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习笔记]]></title>
    <url>%2F2019%2F12%2F05%2Fstudy%2F</url>
    <content type="text"><![CDATA[js:关于类型，有哪些你不知道的细节undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。Undefined 跟 null 有一定的表意差别，null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。 String 有最大长度是 2^53 - 1 基于对象而不是面向对象]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于小程序]]></title>
    <url>%2F2019%2F11%2F19%2Fminiapp%2F</url>
    <content type="text"><![CDATA[登陆逻辑梳理wx.checkSessionwx.login 换取 session_key]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的瀑布流]]></title>
    <url>%2F2019%2F11%2F18%2Fwaterfall%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; position: relative; &#125; .left, .middle, .right &#123; display: inline-block; margin: 30px; width: 500px; height: auto; vertical-align: top; &#125; img &#123; width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container flex&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;img src=&quot;./avatar.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;./tutu.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;img src=&quot;./sister.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;./tutu.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;img src=&quot;./sister.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const el = [&apos;./avatar.jpg&apos;, &apos;./sister.jpg&apos;, &apos;./tutu.jpg&apos;] const $ = dom =&gt; document.querySelector(dom) const left = $(&apos;.left&apos;) const middle = $(&apos;.middle&apos;) const right = $(&apos;.right&apos;) window.addEventListener(&apos;scroll&apos;, () =&gt; &#123; const scrolltop = document.documentElement.scrollTop || document.body.scrollTop const scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight ) const screenHeight = document.documentElement.clientHeight || document.body.clientHeight judgeSize() if (scrollHeight - (screenHeight + scrolltop) &lt;= 100) &#123; for (let i = 0; i &lt; 12; i++) &#123; let img = Math.floor(Math.random() * 3) let dom = judgeSize() dom.innerHTML += `&lt;img src=&quot;$&#123;el[img]&#125;&quot;&gt;&lt;/img&gt;` &#125; &#125; &#125;) const judgeSize = () =&gt; &#123; const leftHeight = left.offsetHeight const middleHeight = middle.offsetHeight const rightHeight = right.offsetHeight const obj = &#123; [leftHeight]: left, [middleHeight]: middle, [rightHeight]: right &#125; let arr = [leftHeight, middleHeight, rightHeight].sort((a, b) =&gt; a - b) return obj[arr[0]] &#125; &lt;/script&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习日记]]></title>
    <url>%2F2019%2F11%2F01%2Fexpress%2F</url>
    <content type="text"><![CDATA[hello,world19.11.1首先来一个 hello,world 123456mkdir expresscd expressnpm init -yyarnyarn add express -Syarn add nodemon -S 好了接下来写代码 12345const express = require(&apos;express&apos;)const app = new express()app.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;hello.world&apos;))app.listen(8888, () =&gt; console.log(&apos;我永远喜欢新垣结衣，8888&apos;)) 学习完毕，关电脑玩游戏（滑稽） routerindex 入口文件 1app.use(&apos;/&apos;, require(&apos;./router/index.js&apos;)) router 下的 index 123456const express = require(&apos;express&apos;)const router = express.Router()router.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;我是主页&apos;))module.exports = router 连接数据库1234mkdir mysqlcd mysqltouch index.jsyarn add mysql -S 安装后在 index.js 里边写入 123456789101112var mysql = require(&apos;mysql&apos;)var dbif (!db) &#123; db = mysql.createPool(&#123; host: &apos;localhost&apos;, user: &apos;admin&apos;, password: &apos;1&apos;, database: &apos;lijiapeng&apos; &#125;)&#125;module.exports = db 然后在路由文件引入 1234567891011const express = require(&apos;express&apos;)const router = express.Router()const db = require(&apos;../mysql&apos;)router.get(&apos;/&apos;, (req, res) =&gt; &#123; db.query(&apos;select * from user&apos;, (err, data) =&gt; &#123; return res.json(data) &#125;)&#125;)module.exports = router]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用操作]]></title>
    <url>%2F2019%2F11%2F01%2Fgit-action%2F</url>
    <content type="text"><![CDATA[分支操作1git checkout -b dev git checkout 加上 -b 参数表示创建并切换，相对于以下两条命令 12git branch devgit checkout dev 查看当前分支 -a 可以查看远程分支 1git branch -a 合并分支 1git merge dev 删除本地分支 1git branch -d dev 切换分支完提交到远程 -d 删除远程仓库分支 12git push origin devgit push -d origin dev 标签操作先切换到需要打标签的分支上，然后敲命令 git tag 就可以打一个新标签 12git checkout devgit tag v1.0.0 如果要打在之前的 commit，可以这样写 12git log --pretty=oneline --abbrev-commitgit tag v0.9 f52c633 查看标签列表,git show 可以查看标签信息 12git taggit show &lt;tag&gt; 标签提交到远程 1git push origin &lt;分支名&gt; --tags]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器配置jenkins新手入门]]></title>
    <url>%2F2019%2F10%2F23%2Fjenkins%2F</url>
    <content type="text"><![CDATA[安装 java 并设置环境变量123我有点迷，当时我是自己下载然后用ftp上传上去然后解压，后续其他方法我再试试最好安装10.x版本环境变量地址: vi /etc/profile 安装 docker123456789101112# 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 添加软件源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 添加软国内软件源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 官网推荐# 更新并安装Docker-CEsudo yum install docker-ce docker-ce-cli containerd.io 然后安装 jenkins 镜像1234567891011121314151617181920212223# 查看安装镜像docker image ls# 安装jenkins镜像docker pull jenkinsci/blueocean# 创建一个jenkins目录mkdir /home/jenkins_home# 启动一个jenkins容器 -d后台运行# /home/jenkins_home/:/home/jenkins_home/ 是为了做共享文件夹，从git克隆代码后然后共享到主机进行打包# --name 自定义名字docker run --name jenkins -p 8081:8080 -v /home/jenkins_home/:/home/jenkins_home/ jenkinsci/blueocean -d# 启动docker 启动镜像systemctl start dockerservice docker stop #关闭dockerdocker start jenkins #开启容器docker kill #关闭容器docker restart [container id] #重启容器# 查看正在运行的容器docker ps 成功后应该是下面这个页面 查看端口是否映射成功docker ps -a 浏览器启动虚拟机 IP：端口 获取密钥docker exec -it jenkins bash 配置钉钉机器人通知首先在钉钉创建自定义机器人，添加成功后获取到一个 access_token 保存好创建的时候添加地址即可，我加密然后就不行了然后在 jenkins 配置下载钉钉通知器插件，下载成功后在项目构建后操作选择钉钉通知器]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的拖拽]]></title>
    <url>%2F2019%2F10%2F14%2Fdrap%2F</url>
    <content type="text"><![CDATA[采用了 h5 的新特性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .el &#123; flex-wrap: wrap; &#125; .a, .b &#123; width: 400px; height: 400px; border: 3px solid greenyellow; margin-right: 80px; margin-bottom: 50px; line-height: 400px; text-align: center; font-size: 56px; &#125; .flex &#123; display: flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;el flex&quot;&gt; &lt;div class=&quot;a&quot; draggable=&apos;true&apos;&gt;1&lt;/div&gt; &lt;div class=&quot;b&quot; draggable=&apos;true&apos;&gt;2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let $ = (el) =&gt; document.querySelector(el) let $$ = (el) =&gt; document.querySelectorAll(el) class Drag &#123; constructor(dom) &#123; this.dom = dom this.fromDom = null this.toFrom = null &#125; init() &#123; let filterChild = [...this.dom.childNodes].filter(it =&gt; it.nodeName !== &quot;#text&quot; &amp;&amp; !/\s/.test(it.nodeValue)) filterChild.map(it =&gt; &#123; it.setAttribute(&apos;draggable&apos;, &apos;true&apos;) this.dragStart(it) this.dragEnter(it) this.drop(it) &#125;) &#125; dragStart(dom) &#123; let that = this dom.ondragstart = function () &#123; that.fromDom = dom &#125; &#125; dragEnter(dom) &#123; let that = this dom.ondragover = function (e) &#123; that.toFrom = dom e.preventDefault(); &#125; &#125; drop(dom) &#123; let that = this dom.ondrop = function (e) &#123; let d = that.fromDom.innerHTML that.fromDom.innerHTML = that.toFrom.innerHTML that.toFrom.innerHTML = d that.fromDom = null that.toDom = null &#125; &#125; &#125; let drap = new Drag($(&apos;.el&apos;)) drap.init()&lt;/script&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[获取滚动条宽度]]></title>
    <url>%2F2019%2F10%2F12%2F%E8%8E%B7%E5%8F%96%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223let scrollBarWidth;export default function () &#123; if (scrollBarWidth !== undefined) return scrollBarWidth; const outer = document.createElement(&apos;div&apos;); outer.style.visibility = &apos;hidden&apos;; outer.style.width = &apos;100px&apos;; outer.style.position = &apos;absolute&apos;; outer.style.top = &apos;-9999px&apos;; document.body.appendChild(outer); const widthNoScroll = outer.offsetWidth; outer.style.overflow = &apos;scroll&apos;; const inner = document.createElement(&apos;div&apos;); inner.style.width = &apos;100%&apos;; outer.appendChild(inner); const widthWithScroll = inner.offsetWidth; outer.parentNode.removeChild(outer); scrollBarWidth = (widthNoScroll - widthWithScroll) / (window.devicePixelRatio || 2); return scrollBarWidth&#125; 实现弹窗背景固定方法12345678910111213141516171819let top = 0export function lock(isFixed = true) &#123; let bodyEl = document.body console.log(ScrollBarWidth()) if (isFixed) &#123; top = window.scrollY bodyEl.style.position = &apos;fixed&apos; bodyEl.style.top = `-$&#123;top&#125;px` bodyEl.style.right = `$&#123;ScrollBarWidth()&#125;px` &#125; else &#123; bodyEl.style.position = &apos;&apos; bodyEl.style.right = &apos;&apos; bodyEl.style.top = &apos;&apos; window.scrollTo(0, top) // 回到原先的top &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的工具]]></title>
    <url>%2F2019%2F07%2F15%2Fhtml%2F</url>
    <content type="text"><![CDATA[超出行隐藏12345overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2; 参数可为任意行数 实现一个 compose1234567891011121314function compose(...fns) &#123; return function (x) &#123; return fns.reduce(function (arg, fn) &#123; return fn(arg); &#125;, x) &#125; &#125; function a(num) &#123; return num + 5 &#125; function b(num) &#123; return num + 2 &#125; console.log(compose(a, b)(5)) 去掉滚动条1.element::-webkit-scrollbar &#123;display:none&#125; flex 一些经常使用的方法flex-direction:主轴的方向 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 align-content 定义了多根轴线的对齐方式 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 一些判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let userAgent = &apos;&apos;if (typeof navigator !== &apos;undefined&apos;) &#123; userAgent = navigator.userAgent.toLowerCase()&#125;// ios浏览器export const isiOS = /applewebkit/i.test(userAgent)// 微信浏览器export const isWx = /micromessenger/i.test(userAgent)// 支付宝export const isAliPay = /alipayclient/.test(userAgent)/** * @desc 判断是否pc页面 * @return &#123;Boolean&#125; */export const isPc = !/Android|webOS|iPhone|iPod|BlackBerry/i.test(userAgent)/** * @desc 判断是否为手机号 * @param &#123;String|Number&#125; str * @return &#123;Boolean&#125; */export function isPhone(str) &#123; return /^(0|86|17951)?1[3456789]\d&#123;9&#125;$/.test(str)&#125;/** * @desc 判断是否为邮箱地址 * @param &#123;String&#125; str * @return &#123;Boolean&#125; */export function isEmail(str) &#123; return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str)&#125;/** * @desc 判断是否是数字 * @param &#123;String|Number&#125; str * @return &#123;Boolean&#125; */export function isNum(str) &#123; return /^[0-9]+([.]&#123;1&#125;[0-9]+)&#123;0,1&#125;$/.test(str)&#125;/** * * @desc 判断是否为身份证号 * @param &#123;String|Number&#125; str * @return &#123;Boolean&#125; */export function isIdCard(str) &#123; return /^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/.test( str )&#125; ###]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制粘贴功能]]></title>
    <url>%2F2019%2F06%2F05%2Fcopy%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728function copyTextToClipboard(text) &#123; var textArea = document.createElement(&quot;textarea&quot;) textArea.style.position = &apos;fixed&apos; textArea.style.top = 0 textArea.style.left = 0 textArea.style.width = &apos;2em&apos; textArea.style.height = &apos;2em&apos; textArea.style.padding = 0 textArea.style.border = &apos;none&apos; textArea.style.outline = &apos;none&apos; textArea.style.boxShadow = &apos;none&apos; textArea.style.background = &apos;transparent&apos; textArea.value = text document.body.appendChild(textArea) textArea.select() try &#123; var msg = document.execCommand(&apos;copy&apos;) ? &apos;成功&apos; : &apos;失败&apos; alert(&apos;复制内容 &apos; + msg); &#125; catch (err) &#123; alert(&apos;不能使用这种方法复制内容&apos;); &#125; document.body.removeChild(textArea)&#125; copyTextToClipboard(‘新垣结衣’)]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题收集]]></title>
    <url>%2F2019%2F02%2F20%2FInterview%2F</url>
    <content type="text"><![CDATA[想必大家很厌烦笔试，因为脑海中都是一些分散的知识点，无法关联成网，一直处于时曾相识的状态。不知道多少人和我一样，至今每次写阻止冒泡都需要百度一番如何拼写。 CSS1.盒模型页面渲染时，dom 元素所采用的布局模型。可通过 box-sizing 进行设置。根据计算宽高的区域可分为： content-box (W3C 标准盒模型,在宽度和高度之外绘制元素的内边距和边框) border-box (为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制) inherit (从父元素继承 box-sizing 属性的值) 2.层叠上下文 z-index 属性值并不是在任何元素上都有效果。它仅在定位元素（定义了 position 属性，且属性值为非 static 值的元素）上有效果 判断元素在 Z 轴上的堆叠顺序，不仅仅是直接比较两个元素的 z-index 值的大小，这个堆叠顺序实际由元素的层叠上下文、层叠等级共同决定。层叠上下文通俗的讲就是，两个父元素各自有一个子元素，子元素全部设置有 position 和 z-index，那么这时候因为父元素没有设置 z-index，所以没有产生上下文，此时 z-index 谁大谁就在上面,如果两个父元素同时设置了 z-index,就算你其中子元素的 z-index 设置了 99999 也没用，因为你的父元素所产生的层叠上下文比别人的小，也就是 z-index。 3.居中布局水平居中 行内元素: text-align:center 块级元素: margin:0 auto absolute+transform（position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);） flex+justify-content:center 垂直居中 line-height:height absolute+transform flex+align-items:center display: table-cell 水平垂直居中 absolute+transform flex+justify-content+align-items 4.选择器优先级 !important &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认 选择器从右往左解析 5.去除浮动影响，防止父级高度塌陷 通过增加尾元素清除浮动(::after{content:’’;clear:both;display:block;}) 父级设置高度 父元素设置 overflow:hidden; javascript1.原型 / 构造函数 / 实例12345678原型(prototype):一个简单的对象，用于实现对象的属性继承。可以简单的理解成对象的爹。在Firefox和Chrome中，每个JavaScript对象中都包含一个 __proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。构造函数:可以通过new来新建一个对象的函数。实例: 通过构造函数和new创建出来的对象，便是实例,实例通过 __proto__指向原型，通过constructor指向构造函数。实例.__proto__ === 原型原型.constructor === 构造函数构造函数.prototype === 原型原型.constructorr === 构造函数 2.原型链123原型链是由原型对象组成，每个对象都有__proto__属性，指向了创建该对象的构造函数的原型，__proto__将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。具体还是去这个网站吧https://www.jianshu.com/p/dee9f8b14771 3.作用域作用域其实可理解为该上下文中声明的变量和声明的作用范围。可分为块级作用域和函数作用域 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量 非匿名自执行函数，函数变量为只读状态，无法修改 123456const foo = 1(function foo() &#123; foo = 10 // 由于foo在函数中只为可读，因此赋值无效 console.log(foo)&#125;())// 结果打印： ƒ foo() &#123; foo = 10 ; console.log(foo) &#125; 4.作用域链我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。 5.闭包闭包属于一种特殊的作用域，称为静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。闭包也会产生一个问题： 多个子函数都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。解决方法： 变量可以通过函数参数的形式传入 使用块级作用域，让变量成为自己上下文的属性，避免共享 6.对象的拷贝浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign …扩展运算符深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响 当值为函数或 undefined 时，无法拷贝 JSON.parse(JSON.stringify(obj)): 性能最快 递归进行逐一赋值 7.new 运算符的执行过程 新生成一个对象 链接到原型 prototype 绑定 this 返回新对象 8.代码的复用 函数封装 继承 混入 mixin 模式（感觉和继承差不多鸭） 借用 apply/call 9.继承在 JS 中，继承通常指的便是原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。 使用 ES6 的语法糖 class/extends 10.类型转换在 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下: -、*、/、% ：一律转换成数值后计算 [1].toString()===’1’ {}.toString()===’[object object]’ +： 数字 + 字符串 = 字符串， 运算顺序是从左到右 数字 + 对象， 优先调用对象的 valueOf -&gt; toString 数字 + boolean/null = 数字 数字 + undefined == NaN 11.类型判断判断类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待 基本类型(null): 使用 String(null) 基本类型(string/number/boolean/undefined) + function: 直接使用 typeof 即可 其余引用类型(Array/Date/RegExpError): 调用 toString 后根据 [objectXXX]进行判断 12.模块化 es6: import/exports commonjs: require/module.exports/exports require 与 import 的区别 require 支持动态导入， import 不支持，正在提案 (babel 下可支持) require 是同步导入， import 属于异步导入 require 是值拷贝，导出值变化不会影响导入值； import 指向内存地址，导入值会随导出值而变化 13.防抖与节流具体看前几篇的博客 14.this 指向要明白 this 指向，其实就是要搞清楚函数的运行环境，说人话就是，谁调用了函数。例如: obj.fn()，便是 obj 调用了函数，既函数中的 this===obj fn()，这里可以看成 window.fn()，因此 this===window 但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向: call:fn.call(target,1,2) apply:fn.apply(target,[1,2]) bind:fn.bind(target)(1,2) 这三种方式在前几篇博客有详情 15.ES6/ES7 声明:let/const: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明,const: 声明常量，无法修改 解构赋值 class/extend: 类声明与继承 Set/Map: 新的数据结构 Promise 的使用与实现,await/async 具体参考阮一峰的 es6 入门：http://es6.ruanyifeng.com/#README 16.数组 map: 遍历数组，返回回调返回值组成的新数组 forEach: 无法 break，可以用 try/catch 中 thrownewError 来停止 filter: 过滤 sort(fn)/reverse: 排序与反转，改变原数组 concat: 连接数组，不影响原数组， 浅拷贝……. 浏览器常见状态码 1xx: 接受，继续处理 200: 成功，并返回数据 201: 已创建 202: 已接受 203: 成为，但未授权 204: 成功，无内容 205: 成功，重置内容 206: 成功，部分内容 301: 永久移动，重定向 302: 临时移动，可使用原有 URI 304: 资源未修改，可使用缓存 305: 需代理访问 400: 请求语法错误 401: 要求身份认证 403: 拒绝请求 404: 资源不存在 500: 服务器错误 get / postget: 缓存、请求长度受限、会被历史保存记录post: 安全、大数据、更多编码类型 框架：Vue1.nextTick在下次 dom 更新循环结束之后执行延迟回调，可用于获取更新后的 dom 状态 2. 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年我绝对不会再买的东西]]></title>
    <url>%2F2019%2F01%2F20%2Fshop%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我的工资都浪费在哪些地方？top1 鞋子据统计今年我总共买了四双鞋子，总共花费约800元左右，无法想象，记得以前我买了两双特步换着穿两三年才有闲钱换了新的，现在真有点膨胀，这四双鞋中，买完就后悔的有两双，首先是阿迪的这双不懂为什么阿迪的41号跟别家的41号不同，我穿着有一点显大而且很容易拖鞋垫，就是你大街上走着走着鞋垫就从后脚跟拖出来了…反正我现在穿它基本就不垫鞋垫了，透气性很适合春夏秋穿至于弹性还行吧跟想象的不一样，接下来是特步家的,这双鞋弹性一般透气可以质量差评，刚穿了一个月撑起鞋舌的那个穿孔就掉了- -…剩下两个还是特步家的，一个运动鞋一个老爹鞋，目前没有任何问题，穿着舒适 top2 烤箱和面包机也不是不能不买，而是买了之后感觉有点用处但是有点鸡肋，18年刚工作的时候想给家里添件电器，家里其他也不缺而我当时被烘焙洗脑了就花了几百块买了个烤箱给我妈，买烤箱的目的就只有一个做面包！但由于技术实在太菜每次都做成馒头硬的不像话，不过实话实说烤箱的质量很不错，但但是！我妈不会烘焙我也是屁股塞黄豆一窍不通，所以主要的功能就是我回家后做鸡胸肉了其余时间都在闲置着，过了一段时间不甘心的我在年中的时候买了一台面包机，这下好了傻瓜式操作，面粉和水的比例说明书都有，总算是满足了我做面包的念想,做了几次后就乏味了，成本太高味道不理想也弃了偶尔健身拿来做早餐吃也是美滋滋 top3 质量差的生活用品没什么好解释的贪便宜买的价格看起来还行，其实我是蹭了商家的活动，买一赠一，收到衣服后会返回支付款的一半，这些衣服买来之后或多或少都会出现些问题，起毛了等等等等，相比起我在优衣库买的衣服简直就是个屁 top4 伪文艺小清新生活用品记得在淘宝上第一眼看见就喜欢的不得了，买来之后也装了几天衣服后来因为被褥枕头太多就当成集装箱用了…..还有一些瓶子笔盒什么的我都不知道自己当时脑子怎么想的，我还在屋子里用塑料杯种了一些草…. top5 健身之类的..觉得好酷炫就买了，结果还不如我原先是用过的杯子… top6 电锅从此我知道了宁愿买电磁炉加铁锅也不能买电锅，再买吃一吨屎！ top7 住宿以后再租房的话不会再租这么贵了，一年光房租花了我1W7.8]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js防抖和节流]]></title>
    <url>%2F2018%2F12%2F28%2Fjs%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[JS 防抖&emsp;&emsp;最近在做公司商城项目时候，有个需求就是购物车里边，数量 input 框需要根据你当前输入的值，每次输入都要发送更新请求，然后后端进行计算，前端重新渲染页面，那么问题来，我每次输入一个数字都会发送一个请求到后端，这样就非常的浪费资源，页面加载也会变慢，于是我查看了下淘宝的购物车页面，发现他们是输入框输入数字停顿大概零点几秒后再开始发送请求，而不是像我这样每次输入都发送，然后我就找到了 js 防抖 原文网址：https://juejin.im/post/5b8de829f265da43623c4261?utm_source=gold_browser_extension我把原文缩减了下写了个小 demo直接上代码 1234567891011121314html： &lt;input id=&apos;debounce&apos; /&gt;JS:var timer = false;function debounce(delay) &#123; clearTimeout(timer) // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function () &#123; console.log(&apos;函数鸡柳&apos;) &#125;, delay)&#125;let inputb = document.getElementById(&apos;debounce&apos;)inputb.addEventListener(&apos;keyup&apos;, function (e) &#123; debounce(500)&#125;) 函数防抖的要点，需要一个 setTimeout 来辅助实现,延迟执行需要跑的代码如果方法多次触发，则把上次记录的延迟执行代码用 clearTimeout 清掉，重新开始多用于用户名邮箱等等认证，或购物车数量 JS 节流规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效 123456789101112131415&lt;input type=&quot;text&quot; id=&quot;d1&quot;&gt;var time = 0document.getElementById(&quot;d1&quot;).onkeyup=function()&#123; set()&#125;function set()&#123; var date = new Date().getTime() if(date-time&gt;=2000)&#123; timer = setTimeout(e=&gt;&#123; console.log(&quot;红烧&quot;) time = date &#125;,2000) &#125;&#125; 然后你就会发现他会每隔 2 秒执行一次节流我的思路就是每次输入的时候获取当前的毫秒数，如果当前毫秒数减去上一次的毫秒数&gt;=2000 了，这时候开始进行定时器的逻辑，定时器结束后把结束的时间换成当前的 time函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于bind，apply，call以及箭头函数的区别]]></title>
    <url>%2F2018%2F12%2F27%2Fthis%2F</url>
    <content type="text"><![CDATA[call,apply不比比，直接上代码 12345678910111213function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 在使用 call 和 apply 时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 ‘foo’ 转化成 new String(‘foo’) 这样如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） bindbind 是 es5 新加的，当你调用 bind 的时候，跟 call 和 apply 不同，他返回的是一个新函数，新函数 this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。 123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&apos;yoo&apos;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty 箭头函数在箭头函数中，this 与封闭词法上下文的 this 保持一致。在全局代码中，它将被设置为全局对象 1234567891011121314151617var globalObject = this;var foo = (() =&gt; this);console.log(foo() === globalObject); // true//如果将this传递给call、bind、或者apply，它将被忽略。// 接着上面的代码// 作为对象的一个方法调用var obj = &#123;foo: foo&#125;;console.log(obj.foo() === globalObject); // true// 尝试使用call来设定thisconsole.log(foo.call(obj) === globalObject); // true// 尝试使用bind来设定thisfoo = foo.bind(obj);console.log(foo() === globalObject); // true 最后一点，当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。 12345678var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式入门笔记]]></title>
    <url>%2F2018%2F12%2F24%2Freg%2F</url>
    <content type="text"><![CDATA[正则一直是我弱项，闲着没事写笔记学习吧~ RegExp 对象js 的内置对象 RegExp 支持正则表达式有两种方法实例化 RegExp 对象 字面量 var reg = /a/ 构造函数 var reg = new RegExp(‘/a/‘) 元字符正则表达式由两种基本字符类型组成 原义文本字符，也就是我想搜索 a 那就/a/ 元字符，在正则表达式中有特殊含义的非字母字符比如\b 边界，以及 * + ? ^ () {} [] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \o 空字符 \f 换页符 \cX 与 X 对应的控制字符 字符类有时候我们不想特指某个字符，想匹配某个范围内 我们可以用元字符 [] 来构建一个简单的类 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符 表达式[abc]就把字符 a,b,c 归为一类，表达式可以匹配这类的字符 字符类取反 使用元字符^创建反向类/负向类 反向类的意思是不属于某类的内容 表达式[^abc]标识不是字符 a,b,c 的内容 范围类我们想匹配所有数字，或者所有字母的时候，正则提供了范围类 [a-z]就表示从 a 到 z 的任意字符 这是个闭区间，也包含 a 和 z 本身 也可以连着写[a-zA-Z0-9],如果想匹配-这个字符就在匹配的后面加上-例如[a-z-] 预定义类+边界 预定义类+边界 含义 . 除了换行符和回车符以外的所有字符 \d 数字字符([0-9]) \D 非数字字符([^0-9]) \s 空白符 \S 非空白符 \w 单词字符([a-zA-Z_0-9]) \W 非单词字符 ^ 以 xxxx 开始 \$ 以 xxxx 结束 \b 单词边界 \B 非单词边界 量词当你希望匹配一个数字出现 20 次的时候，你可以这样写/\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d/……这样写是极其不友好，谁写是傻子 字符 含义 ? 出现 0 次或者 1 次(最多出现一次) + 出现一次或多次(最少出现一次) * 出现 0 次或多次(任意次) {n} 出现 n 次 {n,m} 出现 n 到 m 次 {n,} 至少出现 n 次 贪婪模式和非贪婪模式比如表达式\d{3,6}，可以匹配到三个数字，也可以是四个五个六个……来看例子 12&apos;12345678&apos;.replace(/\d&#123;3,6&#125;/g,&apos;A&apos;)&apos;A78&apos; 从这可以看出正则表达式默认的是尽可能多的匹配，而不是只匹配到第三个就结束了，这就是贪婪模式 非贪婪模式 让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试，就是非贪婪模式做法很简单，在量词后加上?即可 12&apos;12345678&apos;.replace(/\d&#123;3,6&#125;?/,&apos;X&apos;)&quot;X45678&quot; 分组比如我们想匹配 abc 3 次的时候我们可以这样写abc{3}但是这样写就会匹配 c 的 3 次，而不是整个字母 abc 的 3 次，要想作用于整个字母就要使用()来分组(abc){3} 或js 里边是 || 而正则是使用 | 可以达到或的效果a|c 反向引用2015-15-25 =&gt; 25/15/2015&#39;2015-12-25&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/,&#39;$3/$2/$1&#39;)如果你不希望捕获分组可以在()内加上?:(?:\d{2}) 前瞻和后瞻 名称 正则 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) exp(?=assert) 的意思就是比如你要匹配 a 但是 a 后边必须要跟上数字 就是这样写/\w(?=\d)/，上代码看下和平常的区别 1234&apos;a2b2&apos;.replace(/\w\d/,&apos;A&apos;)&quot;Ab2&quot;&apos;a2b2&apos;.replace(/\w(?=\d)/,&apos;A&apos;)&quot;A2b2&quot; 对象属性修饰符 g:global 全局搜索，不添加，搜索到第一个停止 i:ignore case 忽略大小写，默认大小写敏感 m:multiple lines 多行搜索 lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置,该属性只有设置标志 g 才能使用。 source 正则表达式的文本字符串 test用于测试字符串参数中是否存在匹配正则表达式模式的字符串 12/\d/g.test(&apos;0&apos;)true 但是你多执行几次就会出现… 123456789var reg = /\d/greg1.test(0)truereg1.test(0)falsereg1.test(0)truereg1.test(0)false 这是为撒呢？因为 test 是以 lastIndex 属性所指的位置作为下次检索的起始点，所以你就可以遍历一个字符串的所有文本,等它再也找不到可以匹配的文本时，它会自动把 lastIndex 属性重置为 0，所以返回了 false 12345678var reg = /\w/gwhile(reg.test(&apos;ab&apos;))&#123; console.log(reg.lastIndex)&#125;12 exec使用正则表达式对字符串进行搜索，如果没有匹配返回 null，匹配到返回结果数组,数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是正则中分组中表达式相匹配的值，一次类推，看实例 12345678var reg = /\d(\w)\d/var ret = reg.exec(&apos;$5a51s28e6&apos;)console.log(ret.index,reg.lastIndex,ret.toString(),ret.input)10&quot;5a5,a&quot;&quot;$5a51s28e6&quot; 从实例中可以看出 exec()方法还返回两个属性，index 属性声明的是匹配文本的第一个字符的位置，input 属性则存放的是被检索的字符串 string。其中 5a5 是检索到的字符串，而 a 是分组(\w)检索出来的属性，再换个写法试试 12345var reg = /\d(\w)(\w)\d/var ret = reg.exec(&apos;$5aw51s28e6&apos;)console.log(ret.toString())&quot;5aw5,a,w&quot; a 和 w 都是分组中两个属性 字符串的对象方法search search()方法用于检索字符串中指定的子字符串，或检索与正则表达式想匹配的子字符串，方法返回第一个匹配结果 index，查找不到返回-1，search 方法不支持全局匹配，忽略标志 g，并且从字符串的开始进行检索 1234&apos;1w5w2w&apos;.search(&apos;1&apos;)0&apos;1w5w2w&apos;.search(&apos;10&apos;)-1 match match()方法将检索字符串，找到一个或多个与正则匹配的文本，是否标志 g 对结果影响很大]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux学习挖坑]]></title>
    <url>%2F2018%2F12%2F23%2FReact-Redux%E5%AD%A6%E4%B9%A0%E6%8C%96%E5%9D%91%2F</url>
    <content type="text"><![CDATA[什么是 Redux Redux 是一个流行的 JavaScript 框架，为应用程序提供一个可预测的状态容器。Redux 基于简化版本的 Flux 框架，Flux 是 Facebook 开发的一个框架。在标准的 MVC 框架中，数据可以在 UI 组件和存储之间双向流动，而 Redux 严格限制了数据只能在一个方向上流动 在 Redux 中，所有的数据（比如 state）被保存在一个被称为 store 的容器中 → 在一个应用程序中只能有一个。store 本质上是一个状态树，保存了所有对象的状态。任何 UI 组件都可以直接从 store 访问特定对象的状态。要通过本地或远程组件更改状态，需要分发一个 action。分发在这里意味着将可执行信息发送到 store。当一个 store 接收到一个 action，它将把这个 action 代理给相关的 reducer。reducer 是一个纯函数，它可以查看之前的状态，执行一个 action 并且返回一个新的状态。项目撸起来首先创建一个 react 脚手架项目create-react-app my-app接下来 cd 到项目当中，安装 reduxyarn add redux -S页面 index.jsimport {createStore} from &#39;redux&#39; StateStore 对象包含所有数据， 当前时刻的 State，可以通过 store.getState()拿到。 1234//新建storeconst store = createStore(reducer);const state = store.getState();console.log(state); ActionState 的变化，会导致页面的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。其他属性可以自由设置const action = {type:&#39;0&#39;} store.dispatch()派发事件，接受 action，将当前的 action 传输给 reducer，生成新的 statestore.dispatch(action) Reducerstore 收到 action 后，经过一些逻辑计算也就是 reducer，然后生成一个新的 state 123456789101112//通过reducer遍历//根据老的state和action来生成新的statefunction reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125; store.subscribe()订阅事件，一旦 State 发生变化，就自动执行这个函数 12345//订阅事件function listener()&#123; console.log(store.getState())&#125;store.subscribe(listener); 下面直接来一个 demo 吧，index.js 123456789101112131415161718192021222324252627282930313233343536import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import &#123;createStore&#125; from &apos;redux&apos;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;function reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125;const store = createStore(reducer);const state = store.getState();//订阅事件function listener()&#123; console.log(store.getState())&#125;store.subscribe(listener);//派发事件const action = &#123;type:&apos;0&apos;&#125;store.dispatch(action);store.dispatch(action);store.dispatch(action);ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));registerServiceWorker(); 页面打印出 React 怎么和 Redux 一起使用呢 把 store.dispatch 方法传递给组件，内部可以调用修改状态 Subscribe 订阅 render 函数，每次修改都重新渲染 Redux 相关代码，转移到 redux.js 进行管理 在 src 目录创建 redux.js，然后将 reducer 函数放入 redux.jsindexjs: 1234567891011121314import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import &#123;createStore&#125; from &apos;redux&apos;;import App from &apos;./App&apos;;import &#123;reducer,add&#125; from &apos;./redux&apos;;const store = createStore(reducer);function render()&#123; ReactDOM.render(&lt;App store=&#123;store&#125; add=&#123;add&#125;/&gt;, document.getElementById(&apos;root&apos;));&#125;render()store.subscribe(render); redux.js: 12345678910111213export function reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125;export function add()&#123; return &#123;type:&apos;0&apos;&#125;&#125; 页面 app.js 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;class App extends Component &#123; render() &#123; var store = this.props.store; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;store.getState()&#125;&lt;/p&gt; &lt;button onClick=&#123;e=&gt;store.dispatch(this.props.add())&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这样页面中，每点击一次 button，返回来的 state 就会加 1 更进一步，处理异步，调试工具，与 react 更优雅的结合Redux 默认只处理同步，处理异步，需要 redux-thunk 插件使用 applyMiddleware 开始 thunk 中间件Action 可以返回函数，使用 dispatch 提交 actionyarn add redux-thunk --saveindex.js 123import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;const store = createStore(reducer,applyMiddleware(thunk)); redux.js 1234567export function addd()&#123; return dispatch=&gt;&#123; setTimeout(()=&gt;&#123; dispatch(&#123;type:&apos;0&apos;&#125;) &#125;,1000) &#125;&#125; 刚才咱们返回是对象，这次返回的 action 是一个函数，在 app.js 调用后会发现页面在 1 秒后 state 返回+1redux 调试工具在 chrome 这个就需要大家科学上网了, 点击这里下载 怎么使用该工具？ 新建 store 的时候判断 window.devToolsExtension 使用 compose 结合 thunk 和 window.devToolsExtension 调试窗的 redux 选项卡，实时看到 state index.js 代码 123456import &#123;createStore,applyMiddleware,compose&#125; from &apos;redux&apos;;const store = createStore(reducer,compose( applyMiddleware(thunk), window.devToolsExtension?window.devToolsExtension():a=&gt;a)); 如果出现 state 未初始化这个错误，建议你把工具更新一下~~ 使用 react-reduxyarn add react-redux -S忘记 subscribe，记住 reducer，action 和 dispatch 即可React-redux 提供 connect 和 Provider 两个接口来链接index.js 1234567import &#123; Provider &#125; from &apos;react-redux&apos;;ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); app.js 1234567891011121314151617181920212223import &#123;connect&#125; from &apos;react-redux&apos;;import &#123;addState,remove&#125; from &apos;./redux&apos;;class App extends React.component&#123; render()&#123; const store = this.props.store; return ( &lt;div&gt; &lt;h1&gt;我永远喜欢新垣结衣&#123;this.props.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;e=&gt;this.props.addState()&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;e=&gt;this.props.remove()&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//进行装饰器let mapStatetoProps = state=&gt;&#123; return &#123;num : state&#125;&#125;let action = &#123;addState,remove&#125;App = connect(mapStatetoProps,action)(App)//export default App connect 使用装饰器来写可以省略代码，首先 yarn eject 弹出来个性化配置首先安装一个支持装饰器的插件yarn add babel-plugin-transform-decorators-legacy -D 然后在 package.json 下的 babel 添加一个参数 1234567&quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;react-app&quot;], &quot;plugins&quot;: [ [&quot;import&quot;,&#123;&quot;libraryName&quot;: &quot;antd-mobile&quot;,&quot;style&quot;: &quot;css&quot;&#125;], [&quot;transform-decorators-legacy&quot;] //就是这个 ] &#125;, 添加之后在页面重新书写 connect 123456789101112131415161718192021import &#123;connect&#125; from &apos;react-redux&apos;;import &#123;addState,remove&#125; from &apos;./redux&apos;;@connect( state =&gt; (&#123;num:state&#125;), &#123;addState,remove&#125;)class App extends React.component&#123; render()&#123; const store = this.props.store; return ( &lt;div&gt; &lt;h1&gt;我永远喜欢新垣结衣&#123;this.props.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;e=&gt;this.props.addState()&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;e=&gt;this.props.remove()&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App 这样代码简洁美观]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10月18日]]></title>
    <url>%2F2018%2F12%2F20%2F2019%2F</url>
    <content type="text"><![CDATA[逆光 吴青峰]]></content>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x学习入门]]></title>
    <url>%2F2018%2F12%2F20%2Fwebpack4-x%2F</url>
    <content type="text"><![CDATA[之前一直使用3.x，这次学学4.x，看看跟之前有什么不同的地方没 什么是webpack？ webpack是一个打包工具，他的宗旨是一切静态资源即可打包。有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack将现代js开发中的各种新型有用的技术，集合打包。 一、前端环境搭建我们使用npm或yarn来安装webpack123npm install webpack webpack-cli -g 或者 yarn global add webpack webpack-cli 在webpack3中，webpack本身和它的cli以前都是在同一个包中，第4版他们两者分开了,新建一个webpack的文件夹，webpack,初始化package.json并安装webpack-cli 12cnpm init -y //-y 默认所有的配置cnpm i webpack webpack-cli --save-dev //局部安装 二、部署webpack在上面搭建好的环境项目中，我们来到package.json里配置我们的scripts123&quot;scripts&quot;: &#123; &quot;dist&quot; : &quot;node_modules/.bin/webpack -p&quot; //使用cnpm run dist 就可以打包我们的项目了&#125;, 三、webpackp配置流程篇我们在开发是一般会打包src下的什么文件呢？ 发布时需要的html，css，js 预编译器stylus，less，sass,es6的高级语法 图片字体资源.png，.gif，.ico，.jpg 文件间的require别名@等修饰符等等 webpack-dev-server以及跨域处理 jQuery插件全局使用通过这几点来讲解webpack中webpack.config.js的配置首先在同目录下创建webpack.config.js文件，配置总览大概是这样123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; entry：配置入口文件的地址，可以是单一入口，也可以是多入口。output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。module：配置模块，主要是解析CSS和图片转换压缩等功能。plugins：配置插件，根据你的需要配置不同功能的插件。devServer：配置开发服务功能。 首先是入口文件123456entry: &apos;./index.js&apos;, //可配置多入口文件entry:&#123; &apos;index&apos; : &apos;./index.js&apos;, &apos;demo&apos; : &apos;./demo.js&apos;,&#125; output选项（出口配置）1234567891011121314151617181920//出口文件的配置项output:&#123; //打包的路径 path:path.resolve(__dirname,&apos;dist&apos;), //打包后的引用路径 publicPath: &apos;dist&apos;, //打包的文件名称 filename:&apos;bundle.js&apos; &#125;,//多入口情况下output:&#123; //打包的路径 path:path.resolve(__dirname,&apos;dist&apos;), //打包后的引用路径 publicPath: &apos;dist&apos;, //打包的文件名称 filename:&apos;js/[name].js&apos; &#125;,//[name]的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件。 直接这样写是不对的，需要在头部引入pathconst path = require(&#39;path&#39;)其中path.resolve(__dirname,’dist’)就是获取了项目的绝对路径。接下来在根目录下创建index.js，然后运行node_modules/.bin/webpack如果你是全局安装，直接webpack即可，此条命令针对局部安装 设置webpack-dev-server要执行webpack-dev-server首先要使用npm下载cnpm install webpack-dev-server –-save-dev最简单的几项配置如下123456789101112131415devServer:&#123; //设置基本目录结构 contentBase:path.resolve(__dirname,&apos;dist&apos;), //服务器的IP地址，可以使用IP也可以使用localhost host:&apos;localhost&apos;, //服务端压缩是否开启 compress:true, //配置服务端口号 port:1717 proxy : [&#123; context: [&apos;/admin&apos;], target: &quot;http://mcljp.com&quot;, changeOrigin : true &#125;]&#125; contentBase:配置服务器基本运行路径，用于找到程序打包地址host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhostcompress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717.proxy : 本地代理，可进行跨域 开启热更新，你要是直接webpack-dev-server是不行的，需要在json文件下配置下scripts1234&quot;scripts&quot;: &#123; &quot;dev&quot;:&quot;webpack-dev-server --open&quot; &#125;,//--open命令运行后自动打开浏览器进行浏览 配置好保存后，在终端里输入 npm run dev 就可以进行浏览了 四、配置模块 loaders是Webpack最重要的功能之一，通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）query：为loaders提供额外的设置选项（可选） 打包css文件根目录下创建css文件，然后js文件require引入,npm安装style-loader，css-loadercnpm install style-loader css-loader --save-dev webpack.config.js的modules修改为下12345678module:&#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ]&#125; 打包HTML文件打包html我们需要用上插件html-webpack-plugin，使用npm安装插件，并在头部引用12npm install --save-dev html-webpack-pluginconst htmlPlugin= require(&apos;html-webpack-plugin&apos;); html-webpack-pugin基本属性如下title: 用来生成页面的 title 元素filename: 输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。template: 模板文件路径，比如‘./index.html’，favicon: 添加特定的 favicon 路径到输出的 HTML 文件中。minify: {} | false , 传递 html-minifier 选项给 minify 输出hash: true | false, 如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和 CSS 文件，对于解除 cache 很有用。cache: true | false，如果为 true, 这是默认值，仅仅在文件修改之后才会发布文件。showErrors: true | false, 如果为 true, 这是默认值，错误信息会写入到 HTML 页面中chunks: 允许只添加某些块 (比如，仅仅 unit test 块)chunksSortMode: 允许控制块在添加到页面之前的排序方式，支持的值：’none’ | ‘default’ | {function}-default:’auto’excludeChunks: 允许跳过某些块，(比如，跳过单元测试的块)chunks：chunks 默认会在生成的 html 文件中引用所有的 js 文件，当然你也可以指定引入哪些特定的文件。根目录下创建index.html12345678910plugins:[ new htmlWebpackPlugin(&#123; template : &apos;index.html&apos;, filename : &apos;index.html&apos;, title : title, inject : true, hash : true, chunks : [&apos;index&apos;] &#125;),] 终端进行打包，你就会发现html文件也被打包在我们的dist目录下了。 图片，字体打包要将图片和字体打包我们需要安装url-loader，首先进行安装npm install --save-dev url-loader接下来进行配置12345678test: /\.(png|jpg|gif)/,use: [&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 5000, outputPath: &apos;resource/&apos; &#125; &#125;] limit : 文件大小小于limit参数，url-loader将会把文件转为DataURLoutputPath : 表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。图片被打包时，就会在输出文件夹下新建（如果没有）一个名为resource的文件夹，把图片放到里面 css单独打包安装后，config.js文件头部引用12npm install --save-dev extract-text-webpack-pluginconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); 引入成功创建实例后需要在plugins属性中进行配置12345678910const extractTextPlugin = new extractTextPlugin(&quot;/css/index.css&quot;)&#123; test: /\.css$/, use : extractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [ &#123; loader: &apos;css-loader&apos; &#125;, ] &#125;)&#125; ES6转ES6Babel的安装与配置cnpm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react在webpack中配置Babel的方法如下12345test:/\.(jsx|js)$/,use:&#123; loader:&apos;babel-loader&apos;,&#125;,exclude:/node_modules/ 需要在根目录下创建.babelrc文件123&#123; &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]&#125; 打包第三方库，比如jQuery使用plugin全局引用ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpackconst webpack = require(&#39;webpack&#39;)引入成功后配置我们的plugins模块12345plugins:[ new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot; &#125;)], 一些杂货铺插件，可用可不用new webpack.BannerPlugin(&#39;买菜的家朋版权所有&#39;)123456789//抽离第三方库，单独打包，不易造成代码冗余new webpack.optimize.CommonsChunkPlugin(&#123; //name对应入口文件中的名字，我们起的是jQuery name:[&apos;jquery&apos;], //把文件打包到哪里，是一个路径 filename:&quot;assets/js/[name].js&quot;, //最小打包的文件模块数，这里直接写2就好 minChunks:2&#125;), 补充：目前发现与之前3.x有两处不同1.webpack.optimize.CommonsChunkPlugin这个打包独立模块的插件已被抛弃更改为123456optimization: &#123; splitChunks: &#123; name: &apos;common&apos;, filename : &apos;js/base.js&apos; &#125; &#125; 2.css打包插件extractTextPlugin已不能进行webpack4.0的打包，需要更新12345678cnpm install --save-dev extract-text-webpack-plugin@next 然后在打包就正常了&quot;devDependencies&quot;: &#123; ... &quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;, ...&#125;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
